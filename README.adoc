:document-title: rbgo-types: Common types and symbols.
:table-caption: off

= *rbgo-types*

[.big]"`**_Common types and symbols._**`"

[caption="" cols="25h,~m" frame=all grid=all width=100%]
|===

|last update
|20230706

|language
|C++

|namespace
|rbgo

|library ref
|rbgotech/rbgo-types

|entry points
|rbgo-types.h

|dependencies
|<stdint.h>

|environment
|VSCode, Platformio

|platform
|all

|framework
|all
|===

=== **Description**

This repository contains basic types and symbols. +
It is included in most of RBGO.tech C++ libraries.

=== **Todo list before including**

**▲ Define symbol `RBGOTYPEDEFS`**

.Inside platformio.ini example:
----
[env:mcu-target]
build_flags =
    -D RBGOTYPEDEFS=0x0007
----

.Bit numbers inside RBGOTYPEDEFS and according typedefs
[options="header" caption="" cols="1h,1m,2m,2m" frame=all grid=all width=100%]
|===
|bit
|symbol
|typedef
|from

4+^m|Low Byte

|1
|RTDF_Ti8
|Ti8 Tu8
|int8_t, uint8_t

|2
|RTDF_Ti16
|Ti16 Tu16
|int16_t, uint16_t

|3
|RTDF_Ti
|Ti Tu
|int, unsigned int

|4
|RTDF_Ti32
|Ti32 Tu32
|int32_t, uint32_t

|5
|RTDF_Ti64
|Ti64 Tu64
|int64_t, uint64_t

|6
|<reserved>
|
|

|7
|<reserved>
|
|

|8
|<reserved>
|
|

4+^m|High Byte

|1
|<reserved>
|
|

|2
|<reserved>
|
|

|3
|<reserved>
|
|

|4
|<reserved>
|
|

|5
|<reserved>
|
|

|6
|RTDF_TfLD
|TfLD
|long double

|7
|RTDF_Tf64
|Tf64
|double

|8
|RTDF_Tf32
|Tf32
|float
|===

.NOTES
----
● So the example with the mcu-target set bits 1-3, which will only
typedef up to 16 bit integers and whatever the natural int is for that target.
● Assert: Do not use undefined/reserved fields.
● Look inside platformio.ini for various build_flags to test with.
----

**▲ #include rbgo-types.h**

**▲ Compile for target**

=== **Macros**

These macros are to read RBGOTYPEDEFS minimalistic, that is with minimal code.

.Defined macros
[options="header" caption="" cols="1m,4m" frame=all grid=all width=100%]
|===
|name
|task

|RTDF(f)
|(!!(RBGOTYPEDEFS & (f)))

|RTDFa(f)
|(RTDF(f) && RTDF(g))

|RTDFa2(f,g)
|(RTDF(f) && RTDF(g))

|RTDFa3(f,g,h)
|(RTDF(f) && RTDF(g) && RTDF(h))

|RTDFa4(f,g,h,i)
|(RTDF(f) && RTDF(g) && RTDF(h) && RTDF(i))

|RTDFo2(f,g)
|(RTDF(f) \|\| RTDF(g))

|RTDFo3(f,g,h)
|(RTDF(f) \|\| RTDF(g) \|\| RTDF(h))

|RTDFo4(f,g,h,i)
|(RTDF(f) \|\| RTDF(g) \|\| RTDF(h) \|\| RTDF(i))
|===

=== **Why?**

There is no way to reliably/conveniently automate detection inside a header file
for a target platform of what types and their bit width are supported, and
then only typedef the appropriate types.

Knowing the specs of a platform upfront and set RBGOTYPEDEFS
according to it is a hard defined way. +
RBGOTYPEDEFS must represent what types are supported by a platform, and it is why
it must be set inside platformio.ini for a particular compile target.

If inside the dependency tree of an application, a type happens
to be used, that is canceled out by RBGOTYPEDEFS for a target platform,
a compile error will occur, preventing faulty type usage to slip in, 
which otherwise could cause unforeseen and possibly costly mistakes.


